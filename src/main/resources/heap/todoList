тарифы -> базовые тарифы


13.07.03, среда.
Provision -> Product
Fee -> One Time
Order -> Opportunity
orderLevel -> level (передать в Scenario)
OrderDetails -> Scenario
tarificationPlan -> tarifficationScheme
velocity -> speed
client -> customer
accessLineType -> type
agreementPeriod -> contractTerm


13.06.29, суббота.
Попробуй понять как связана тарификация порта и его тип.


13.05.15, среда.
Ты использовал класс OrangeUser для сборки пользователя. Это неправильно. Переделай.

scope "siple thread" то же самое что и TheadLocal, может быть OrderContext - подойдет?

Provision - это энтити, у него есть ссылка на абстрактный энтити Configuration, в свою очередь Configuration
является вершиной иерархии ConfigurationVoice, ConfigurationEasyOffice ...
Тогда при создании заказа Order мы собираем там Provision, причем явно мы там должны создать
объект ConfigurationVoice, ConfigurationEasyOffice ...

13.05.02, четверг.
19.50 - реализовать заход - когда заходит неавторизованный пользователь, ему показывается информационная страница с
сообщением - пока не авторизуешься ничего особого не увидишь.
Для этого надо на главной странице разместить все ссылки, защитив их с помощью spring security.

Планы на майские дни:
30 апреля
1 мая - 12 мая
1. Сделать новую модель данных.
2. Перевести проект на Gradle.
3. Сделать deploy проекта на CloudFoundry, Jelastic и т.п.
4. Сделать полный цикл создания клиентского запроса.
5. Разместить для общего тестирования.
6. Создать библиотеку для хранения контекста.

Библиотека хранения веб-контекста.
1. Позволяет хранить несколько величин.
2. Технология - такая же как хранение UserContext.

Итак:
Переписываем структуру Entity классов
Услуга становится интерфейсом, Все услуги наследуются от нее. Услуги будут Entity (резко упрощаются запросы).
Сколько услуг - столько и классов.
Город - таблица. Тарифы - это справочники.



42. У услуги есть конфигурация.
41. Придется ввести в систему матрицу доступности для городов и скоростей.
40. Запрос клиента на услугу. Услуга может быть не привязана к городу или сайту, может быть привязна к сайту, может
быть привязана к городу (по матрице доступности).
39. Поменять скрипт в новом релизе - меняем version_id на release, добавим еще note - чтобы пользователь мог добавить
коммент к релизу.
CREATE TABLE orderdetails(
  order_id BIGINT(20) NOT NULL,
  site_id BIGINT(20) NOT NULL,
  provision_id BIGINT(20) NOT NULL,
  release BIGINT(20) NOT NULL,
  note TEXT default '',
  expired TINYINT(1) NOT NULL DEFAULT '0',
  UNIQUE KEY UK_ORDERDETAILS (order_id, site_id, provision_id, version_id),
  FOREIGN KEY (order_id) REFERENCES orders(id),
  FOREIGN KEY (site_id) REFERENCES site(id),
  FOREIGN KEY (provision_id) REFERENCES provision(id)
);
38. Прямо сейчас - посмотри свой комикс, надо уже объединять "создание нового заказа" и "редактирование существующего".
37. Переход на gradle.
36. Надо уже добавить параметры к услуге, те что прописаны в "описании предметной области".
Срок контракта, скидка клиенту по данному контракту,
34. В связи с презентацией Минкиной поменять: роли, добавить признак услуги (услуга без привязки к сайту),
для сайта (БЦ/не БЦ, есть ли последняя миля), добавить - Доступ (Тип доступа: основной/резервный, проводной/беспроводной, …)
у услуги есть признак как будет платить клиент - разовый платеж или ежемесячный

33. Вообще-то оператор new работает в последовательностях. Смотри Уоллза - "Спринг в действии" страница 405.
Еще один вариант страница 408, определить переменную var тоже с созданием объекта для того чтобы в него собирать данные
в последовательности.
32. Вопрос номер 31. Надо конечно адрес private/create_dummy_order/{uri1}/{uri2}/{uri3} поменять на такой адрес, чтобы
он захватывался фильтром - /private/calculations/*. Надо бы заново провести эксперимент с работой с OrderContextHolder.
31. Проблема - почему-то я не смог настроить фильтр OrderContextPersistenceFilter.
Дело в том, что при вызове запроса private/create_dummy_order/{uri1}/{uri2}/{uri3} не записывается свежий
OrderContext в репозитарий HttpSessionOrderContextRepository(repo), который есть в фильтре.
Пришлось напрямую работать с сессией чтобы записать свежий OrderContext.
Однако это костыль.
30. Может быть лучше с каждым потоком связывать свой контролер? Пока делаем так (стараюсь).
29. Оформить поддержку сессионности заказов в отдельный jar библиотеку.
28. Поставь защиту от кражи сессий.
27. Поставь ограничение сессий = 1 для пользователей, стр. 350, Winch
26. Можно организовать для админа просмотр активных сессий, есть возможность их удаления админом. Смотри стр.359, Winch
25. Аудит действий пользователя. Можно ли сделать видео аудит экрана пользователя?
24. Перейти на свежую версию spring security и добавить solt.
23. Добавить таймер для пользователя - если пользователь долго отсутствует - делаем ему авто-логаут.
21. Не ощищается поле выбранные сайты при повторном цикле введения пар сайт-услуга.
20. Учитывать и группы при переброске при авторизации пользователей. Смотри класс RoleBasedAuthenticationSuccessHandler
19. Убрать из OrangeUser группы за ненадобностью.
18. В статусной строке надо показывать еще и клиента, ну как и пользователя в том же месте. :)
17. По аналогии с UserDetails надо создавать Order только после формирования полного OrderDetails.
16. Нужно реализовать, чтобы при заведении пользователя он получал временный пароль пароля.
При первом логине надо заставить пользователя поменять пароль.
15. Поместить ссылку на шаблоне - создать заказ, редактировать заказ - которую видит только авторизованный пользователь.
см. стр. 262 по spring security.
14. Поместить наверху где красненькие карта сайта "Вы работаете с заказом номер 33 от 31.01.2013"
13. Надо создать документ - среда окружения (где описываются - сервера, субда и т.п.)
12. Привязать remembe-me возможность к ip-адресам внутренней сети компании.
11. Описание жизненного цикла приложения. Запуск, цепочки, интерсепторы ...
10. Надо ресурсы спрятать подальше - <mvc:resources mapping="/resources/**" location="classpath:/META-INF/web-resources/"/>
9. Надо учесть что у формирования заказа есть возможность удаления всех версий и переход в состоянии окончательной сформированности.
7. Надо сделать отдельную цепочку для создании заказа. Далее, остальные цепочки работают уже с существующим заказом.
6. Надо сделать профили: один для разработки локально, второй для развертывания на jelastic сервере.
5. Рефакторинг: Предыдущий интерсептор, если находит, что заказ не выбран, предлагает создать новый или перейти к
редактированию существующего.
4. Добавить интерсептор, который для цепочек редактирования заказов проверяет установлен ли текущий заказ и версия.
3. Может быть завести класс OrderDetailsManager для управления версиями заказа?
2. Добавить отображение текущего заказа на странице. Может быть сделать тег для этого?

Сделано:
14. Поместить login/logout наверху где красненькие карта сайта eng rus
1. Добавить класс OrderDetailsContext для отслеживания текущей обрабатываемой версии заказа.
Статические методы:
getCurrentOrderDetails
setCurrentOrderDetails
8. Надо учесть что у заказа есть дата создания.
   Надо учесть что заказ может быть создан в различных регионах, надо хранить временную зону. JODATIME
22. Переписать приложение уже на spring и spring-security 3.1.3!!!